<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width">
<title>Crash Rates (Telemetry)</title>

<!-- MG.js stuff --!>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="mgjs/metricsgraphics.min.js"></script>
<link href="mgjs/metricsgraphics.css" rel="stylesheet" type="text/css">

<style>

body {
  font-family: sans-serif;
}

table {
  border-collapse: collapse;
  border-spacing: 0 0;
  border: 1px solid black;
}

td {
  border: 1px solid black;
  padding: 0.1em 0.33em;
}

td.type-float {
  text-align: right;
}

td.clickable {
  cursor: pointer;
}

td.clickable:hover,
td.clickable.clicked {
  background-color: lightgrey;
}

thead {
  font-weight: bold;
}

#notice {
  color: orange;
}

#data {
  height: 25vh;
  width: 90vw;
  margin: 2vmin 0;
}

#subdata {
  height: 25vh;
  width: 90vw;
  margin: 2vmin 0;
}

.mg-active-datapoint tspan tspan:nth-child(2) {
  /* baleet the little circle span, as the circle char doesn't exist in all fonts */
  display: none;
}
</style>
</head>
<body>
<h1>Stability Dashboard</h1>
<h5>Analyzed date: <select id="analyzed-date"></select></h5>
<h3>Firefox Desktop</h3>
<p id="notice">&nbsp;</p>
<table id="data-table">
  <thead>
    <tr>
      <td>Channel</td>
      <td>Nightly</td>
      <td>Aurora</td>
      <td>Beta</td>
      <td>Release</td>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>
<div id="data">
</div>
<div id="subdata">
</div>
<p>Cells are of the form <em>Rate (X%)</em> where:</p>
<dt><em>Rate</em></dt>
<dd>- (for crashes) is the number of that type of crash divided by the usage_khours</dd>
<dd>- (for usage_khours) is just the number of usage_khours<dd>
<dt><em>(X%)</em></dt>
<dd>- (for crashes) is the percent that this week's number (not the rate) of crashes is vs. last week's number (not rate) of that crash</dd>
<dd>- (for usage_khours) is the percent that this week's number is of last week's usage_khours</dd>
<p>Since crash rates are <em>#crashes / usage_khours</em> a low <em>(X%)</em> in <em>usage_khours</em> can result in an inflation of crash rates.</p>
<p>To estimate how much of an inflation, take a relatively-stable crash type (like <em>P</em>) and compare its <em>(X%)</em> to <em>usage_khours</em>'.</p>
<p>As of yet, no model has been developed to do this properly, so YMMV.</p>
<hr/>
<p>Data comes from <a href="https://sql.telemetry.mozilla.org/queries/1092/source#table">this query</a> which DOES NOT CURRENTLY UPDATE, so there.</p>
<script>

const CHANNELS = ["nightly", "aurora", "beta", "release"];
const PERCENT_NOTICE_THRESHOLD = 0.5;

var gData = undefined;
var gMap = {};

var formatHours = function(hours) {
  // values are kilo-usage-hours and range in value from, say,
  // 24.2 (7% of nightly) to
  // 813,816.57 (~100% of release)

  // So... optional "K"?

  hours = Number(hours);
  let suffix = '';
  if (hours < 2000) {
    // do nothing.
  } else {
    hours = hours / 1000;
    suffix = 'k';
  }
  return Number(hours).toFixed(Math.max(0, 2 - Math.ceil(Math.log10(hours)))) + suffix;
}

var xhr = new XMLHttpRequest();
xhr.addEventListener("load", function() {

  try {
    gData  = JSON.parse(this.responseText).query_result.data;
  } catch (e) {
    console.error("Failed a JSON parse");
    console.error(e.message);
    throw e;
  }

  // Re-arrange data into a useful map
  gData.rows.forEach((row) => {
    if (!(row.activity_date in gMap)) {
      gMap[row.activity_date] = {};
    }
    gMap[row.activity_date][row.channel] = row;
  });
  let latestDate = Object.keys(gMap).sort((a, b) => a < b ? 1 : (a > b ? -1 : 0))[0];

  let dateSelect = document.getElementById("analyzed-date");
  for (let i = 0; i < 7; i++) {
    let opt = document.createElement("option");
    let ago = new Date(latestDate);
    ago.setDate(ago.getDate() - i);
    opt.textContent = opt.value = ago.toISOString().slice(0, 10);
    dateSelect.appendChild(opt);
  }
  dateSelect.addEventListener("change", function() {
    rebakeTable(this.selectedOptions[0].value);
    updateNotice(this.selectedOptions[0].value);
    updateSubdata(this.selectedOptions[0].value);
    emptyData();
  });
  rebakeTable(latestDate);
  updateNotice(latestDate);
  updateSubdata(latestDate);
  emptyData();
});

function getWeekAgo(latestDate) {
  let weekAgoDate = new Date(latestDate);
  weekAgoDate.setDate(weekAgoDate.getDate() - 7);
  return weekAgoDate.toISOString().slice(0, 10);
}

function rebakeTable(latestDate) {
  let weekAgoDate = getWeekAgo(latestDate);

  if (!gMap[weekAgoDate]) {
    console.error("No data from a week ago?!");
  }

  let table = document.getElementById("data-table");
  let theadRow = table.getElementsByTagName("tr")[0];
  let tbody = table.getElementsByTagName("tbody")[0];

  // Clear!
  tbody.innerHTML = "";

  gData.columns.forEach((column) => {
    if (['activity_date', 'channel'].includes(column.name)) {
      return;
    }
    let row = document.createElement("tr");
    let cell = document.createElement("td");
    cell.textContent = column.friendly_name;
    row.appendChild(cell);
    tbody.appendChild(row);
    CHANNELS.forEach((channel) => {
      cell = document.createElement("td");
      cell.className = "type-" + column.type;

      // if a number, format it
      if (column.type === "float") {
        if (column.name === "usage_khours") {
          let hours = gMap[latestDate][channel][column.name];
          let percent = Number(Number(hours) / Number(gMap[weekAgoDate][channel][column.name]) * 100).toFixed(1);
          cell.textContent = formatHours(hours) + " (" + percent + "%)";
        } else {
          let crashes = gMap[latestDate][channel][column.name];
          let percent = Number(Number(crashes) / Number(gMap[weekAgoDate][channel][column.name]) * 100).toFixed(1);
          let usage = gMap[latestDate][channel]["usage_khours"];
          cell.textContent = Number(crashes / usage).toFixed(2) + " (" + percent + "%)";

          cell.addEventListener("click", function() {
            for (clicked of document.querySelectorAll("td.clicked")) {
              clicked.classList.remove("clicked");
            }
            this.classList.add("clicked");

            updateData(latestDate, channel, column.name);
          });
          cell.classList.add("clickable");
        }
      } else {
        cell.textContent = gMap[latestDate][channel][column.name];
      }
      row.appendChild(cell);
    });
  });
}

function updateNotice(latestDate) {
  let weekAgoDate = getWeekAgo(latestDate);

  let noticeEl = document.getElementById("notice");
  noticeEl.textContent = "\xa0";

  let minPercent = 10;
  let maxPercent = 0;
  CHANNELS.forEach((channel) => {
    let hours = gMap[latestDate][channel]["usage_khours"];
    let percent = Number(hours) / Number(gMap[weekAgoDate][channel]["usage_khours"]);
    if (percent < minPercent) {
      minPercent = percent;
    }
    if (percent > maxPercent) {
      maxPercent = percent;
    }
  });

  if (maxPercent < PERCENT_NOTICE_THRESHOLD) {
    noticeEl.textContent = '' +
      `The usage_khours for ${latestDate} are low ` +
      `(${Number(minPercent * 100).toFixed(1)}%~${Number(maxPercent * 100).toFixed(1)}%) ` +
      `so you may not want to use these figures.`;
  }
}

function updateSubdata(latestDate) {
  let data = [];
  Object.keys(gMap).forEach(activityDate => {
    let datum = { date: new Date(activityDate) };
    CHANNELS.forEach(channel => datum[channel] = gMap[activityDate][channel].usage_khours);
    data.push(datum);
  });
  MG.data_graphic({
    title: "kusage_hours (log)",
    description: "A description",
    data: data,
    full_width: true,
    full_height: true,
    show_tooltips: false,
    target: "#subdata",
    y_accessor: CHANNELS,
    y_scale_type: "log",
    legend: CHANNELS,
    legend_target: "#none",
    yax_units: "Kuh",
    yax_units_append: true,
    markers: [{date: new Date(latestDate), label: "Analyzed Date"}],
    utc_time: true,
    left: 70,
    top: 50,
    right: 15,
    bottom: 40,
  });
}

function updateData(date, channel, crash) {
  let data = Object.keys(gMap).map(activityDate => {
    return {
      date: new Date(activityDate),
      value: gMap[activityDate][channel][crash] / gMap[activityDate][channel].usage_khours,
    };
  });
  MG.data_graphic({
    title: channel + " " + crash,
    data: data,
    full_width: true,
    full_height: true,
    show_tooltips: false,
    target: "#data",
    legend: [channel + " " + crash],
    legend_target: "#none",
    markers: [{date: new Date(date), label: "Analyzed Date"}],
    utc_time: true,
    interpolate: d3.curveLinear,
    left: 70,
    top: 50,
    right: 15,
    bottom: 40,
  });
}

function emptyData() {
  MG.data_graphic({
    chart_type: "missing-data",
    missing_text: "Click on a crash cell to populate graph",
    target: "#data",
    full_width: true,
    full_height: true,
  });
}

xhr.addEventListener("error", () => {
  console.error("ERROR");
});
xhr.open("GET", "https://sql.telemetry.mozilla.org/api/queries/1092/results.json?api_key=f7dac61893e040ca59c76fd616f082479e2a1c85");
xhr.send();
</script>
</body>
</html>
